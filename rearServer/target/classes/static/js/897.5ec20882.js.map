{"version":3,"file":"js/897.5ec20882.js","mappings":"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","sources":["webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/_lib/requiredArgs/index.js","webpack://PandoraNext-TokensTool/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/toDate/index.js","webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js","webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/startOfDay/index.js","webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/differenceInCalendarDays/index.js","webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/differenceInDays/index.js","webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/constants/index.js","webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/_lib/toInteger/index.js","webpack://PandoraNext-TokensTool/./node_modules/date-fns/esm/parseISO/index.js"],"sourcesContent":["export default function requiredArgs(required, args) {\n  if (args.length < required) {\n    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');\n  }\n}","export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @param {Date|Number} argument - the value to convert\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport default function toDate(argument) {\n  requiredArgs(1, arguments);\n  var argStr = Object.prototype.toString.call(argument);\n\n  // Clone the date\n  if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime());\n  } else if (typeof argument === 'number' || argStr === '[object Number]') {\n    return new Date(argument);\n  } else {\n    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {\n      // eslint-disable-next-line no-console\n      console.warn(\"Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments\");\n      // eslint-disable-next-line no-console\n      console.warn(new Error().stack);\n    }\n    return new Date(NaN);\n  }\n}","/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nexport default function getTimezoneOffsetInMilliseconds(date) {\n  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n  utcDate.setUTCFullYear(date.getFullYear());\n  return date.getTime() - utcDate.getTime();\n}","import toDate from \"../toDate/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\n/**\n * @name startOfDay\n * @category Day Helpers\n * @summary Return the start of a day for the given date.\n *\n * @description\n * Return the start of a day for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|Number} date - the original date\n * @returns {Date} the start of a day\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // The start of a day for 2 September 2014 11:55:00:\n * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 02 2014 00:00:00\n */\nexport default function startOfDay(dirtyDate) {\n  requiredArgs(1, arguments);\n  var date = toDate(dirtyDate);\n  date.setHours(0, 0, 0, 0);\n  return date;\n}","import getTimezoneOffsetInMilliseconds from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\nimport startOfDay from \"../startOfDay/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\nvar MILLISECONDS_IN_DAY = 86400000;\n\n/**\n * @name differenceInCalendarDays\n * @category Day Helpers\n * @summary Get the number of calendar days between the given dates.\n *\n * @description\n * Get the number of calendar days between the given dates. This means that the times are removed\n * from the dates and then the difference in days is calculated.\n *\n * @param {Date|Number} dateLeft - the later date\n * @param {Date|Number} dateRight - the earlier date\n * @returns {Number} the number of calendar days\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // How many calendar days are between\n * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?\n * const result = differenceInCalendarDays(\n *   new Date(2012, 6, 2, 0, 0),\n *   new Date(2011, 6, 2, 23, 0)\n * )\n * //=> 366\n * // How many calendar days are between\n * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?\n * const result = differenceInCalendarDays(\n *   new Date(2011, 6, 3, 0, 1),\n *   new Date(2011, 6, 2, 23, 59)\n * )\n * //=> 1\n */\nexport default function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {\n  requiredArgs(2, arguments);\n  var startOfDayLeft = startOfDay(dirtyDateLeft);\n  var startOfDayRight = startOfDay(dirtyDateRight);\n  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);\n  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);\n\n  // Round the number of days to the nearest integer\n  // because the number of milliseconds in a day is not constant\n  // (e.g. it's different in the day of the daylight saving time clock shift)\n  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);\n}","import toDate from \"../toDate/index.js\";\nimport differenceInCalendarDays from \"../differenceInCalendarDays/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\"; // Like `compareAsc` but uses local time not UTC, which is needed\n// for accurate equality comparisons of UTC timestamps that end up\n// having the same representation in local time, e.g. one hour before\n// DST ends vs. the instant that DST ends.\nfunction compareLocalAsc(dateLeft, dateRight) {\n  var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();\n  if (diff < 0) {\n    return -1;\n  } else if (diff > 0) {\n    return 1;\n    // Return 0 if diff is 0; return NaN if diff is NaN\n  } else {\n    return diff;\n  }\n}\n\n/**\n * @name differenceInDays\n * @category Day Helpers\n * @summary Get the number of full days between the given dates.\n *\n * @description\n * Get the number of full day periods between two dates. Fractional days are\n * truncated towards zero.\n *\n * One \"full day\" is the distance between a local time in one day to the same\n * local time on the next or previous day. A full day can sometimes be less than\n * or more than 24 hours if a daylight savings change happens between two dates.\n *\n * To ignore DST and only measure exact 24-hour periods, use this instead:\n * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.\n *\n *\n * @param {Date|Number} dateLeft - the later date\n * @param {Date|Number} dateRight - the earlier date\n * @returns {Number} the number of full days according to the local timezone\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // How many full days are between\n * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?\n * const result = differenceInDays(\n *   new Date(2012, 6, 2, 0, 0),\n *   new Date(2011, 6, 2, 23, 0)\n * )\n * //=> 365\n * // How many full days are between\n * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?\n * const result = differenceInDays(\n *   new Date(2011, 6, 3, 0, 1),\n *   new Date(2011, 6, 2, 23, 59)\n * )\n * //=> 0\n * // How many full days are between\n * // 1 March 2020 0:00 and 1 June 2020 0:00 ?\n * // Note: because local time is used, the\n * // result will always be 92 days, even in\n * // time zones where DST starts and the\n * // period has only 92*24-1 hours.\n * const result = differenceInDays(\n *   new Date(2020, 5, 1),\n *   new Date(2020, 2, 1)\n * )\n//=> 92\n */\nexport default function differenceInDays(dirtyDateLeft, dirtyDateRight) {\n  requiredArgs(2, arguments);\n  var dateLeft = toDate(dirtyDateLeft);\n  var dateRight = toDate(dirtyDateRight);\n  var sign = compareLocalAsc(dateLeft, dateRight);\n  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));\n  dateLeft.setDate(dateLeft.getDate() - sign * difference);\n\n  // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full\n  // If so, result must be decreased by 1 in absolute value\n  var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);\n  var result = sign * (difference - isLastDayNotFull);\n  // Prevent negative zero\n  return result === 0 ? 0 : result;\n}","/**\n * Days in 1 week.\n *\n * @name daysInWeek\n * @constant\n * @type {number}\n * @default\n */\nexport var daysInWeek = 7;\n\n/**\n * Days in 1 year\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n *\n * @name daysInYear\n * @constant\n * @type {number}\n * @default\n */\nexport var daysInYear = 365.2425;\n\n/**\n * Maximum allowed time.\n *\n * @name maxTime\n * @constant\n * @type {number}\n * @default\n */\nexport var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n\n/**\n * Milliseconds in 1 minute\n *\n * @name millisecondsInMinute\n * @constant\n * @type {number}\n * @default\n */\nexport var millisecondsInMinute = 60000;\n\n/**\n * Milliseconds in 1 hour\n *\n * @name millisecondsInHour\n * @constant\n * @type {number}\n * @default\n */\nexport var millisecondsInHour = 3600000;\n\n/**\n * Milliseconds in 1 second\n *\n * @name millisecondsInSecond\n * @constant\n * @type {number}\n * @default\n */\nexport var millisecondsInSecond = 1000;\n\n/**\n * Minimum allowed time.\n *\n * @name minTime\n * @constant\n * @type {number}\n * @default\n */\nexport var minTime = -maxTime;\n\n/**\n * Minutes in 1 hour\n *\n * @name minutesInHour\n * @constant\n * @type {number}\n * @default\n */\nexport var minutesInHour = 60;\n\n/**\n * Months in 1 quarter\n *\n * @name monthsInQuarter\n * @constant\n * @type {number}\n * @default\n */\nexport var monthsInQuarter = 3;\n\n/**\n * Months in 1 year\n *\n * @name monthsInYear\n * @constant\n * @type {number}\n * @default\n */\nexport var monthsInYear = 12;\n\n/**\n * Quarters in 1 year\n *\n * @name quartersInYear\n * @constant\n * @type {number}\n * @default\n */\nexport var quartersInYear = 4;\n\n/**\n * Seconds in 1 hour\n *\n * @name secondsInHour\n * @constant\n * @type {number}\n * @default\n */\nexport var secondsInHour = 3600;\n\n/**\n * Seconds in 1 minute\n *\n * @name secondsInMinute\n * @constant\n * @type {number}\n * @default\n */\nexport var secondsInMinute = 60;\n\n/**\n * Seconds in 1 day\n *\n * @name secondsInDay\n * @constant\n * @type {number}\n * @default\n */\nexport var secondsInDay = secondsInHour * 24;\n\n/**\n * Seconds in 1 week\n *\n * @name secondsInWeek\n * @constant\n * @type {number}\n * @default\n */\nexport var secondsInWeek = secondsInDay * 7;\n\n/**\n * Seconds in 1 year\n *\n * @name secondsInYear\n * @constant\n * @type {number}\n * @default\n */\nexport var secondsInYear = secondsInDay * daysInYear;\n\n/**\n * Seconds in 1 month\n *\n * @name secondsInMonth\n * @constant\n * @type {number}\n * @default\n */\nexport var secondsInMonth = secondsInYear / 12;\n\n/**\n * Seconds in 1 quarter\n *\n * @name secondsInQuarter\n * @constant\n * @type {number}\n * @default\n */\nexport var secondsInQuarter = secondsInMonth * 3;","export default function toInteger(dirtyNumber) {\n  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {\n    return NaN;\n  }\n  var number = Number(dirtyNumber);\n  if (isNaN(number)) {\n    return number;\n  }\n  return number < 0 ? Math.ceil(number) : Math.floor(number);\n}","import { millisecondsInHour, millisecondsInMinute } from \"../constants/index.js\";\nimport requiredArgs from \"../_lib/requiredArgs/index.js\";\nimport toInteger from \"../_lib/toInteger/index.js\";\n/**\n * @name parseISO\n * @category Common Helpers\n * @summary Parse ISO string\n *\n * @description\n * Parse the given string in ISO 8601 format and return an instance of Date.\n *\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n *\n * If the argument isn't a string, the function cannot parse the string or\n * the values are invalid, it returns Invalid Date.\n *\n * @param {String} argument - the value to convert\n * @param {Object} [options] - an object with options.\n * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * const result = parseISO('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * const result = parseISO('+02014101', { additionalDigits: 1 })\n * //=> Fri Apr 11 2014 00:00:00\n */\nexport default function parseISO(argument, options) {\n  var _options$additionalDi;\n  requiredArgs(1, arguments);\n  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);\n  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {\n    throw new RangeError('additionalDigits must be 0, 1 or 2');\n  }\n  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {\n    return new Date(NaN);\n  }\n  var dateStrings = splitDateString(argument);\n  var date;\n  if (dateStrings.date) {\n    var parseYearResult = parseYear(dateStrings.date, additionalDigits);\n    date = parseDate(parseYearResult.restDateString, parseYearResult.year);\n  }\n  if (!date || isNaN(date.getTime())) {\n    return new Date(NaN);\n  }\n  var timestamp = date.getTime();\n  var time = 0;\n  var offset;\n  if (dateStrings.time) {\n    time = parseTime(dateStrings.time);\n    if (isNaN(time)) {\n      return new Date(NaN);\n    }\n  }\n  if (dateStrings.timezone) {\n    offset = parseTimezone(dateStrings.timezone);\n    if (isNaN(offset)) {\n      return new Date(NaN);\n    }\n  } else {\n    var dirtyDate = new Date(timestamp + time);\n    // js parsed string assuming it's in UTC timezone\n    // but we need it to be parsed in our timezone\n    // so we use utc values to build date in our timezone.\n    // Year values from 0 to 99 map to the years 1900 to 1999\n    // so set year explicitly with setFullYear.\n    var result = new Date(0);\n    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());\n    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());\n    return result;\n  }\n  return new Date(timestamp + time + offset);\n}\nvar patterns = {\n  dateTimeDelimiter: /[T ]/,\n  timeZoneDelimiter: /[Z ]/i,\n  timezone: /([Z+-].*)$/\n};\nvar dateRegex = /^-?(?:(\\d{3})|(\\d{2})(?:-?(\\d{2}))?|W(\\d{2})(?:-?(\\d{1}))?|)$/;\nvar timeRegex = /^(\\d{2}(?:[.,]\\d*)?)(?::?(\\d{2}(?:[.,]\\d*)?))?(?::?(\\d{2}(?:[.,]\\d*)?))?$/;\nvar timezoneRegex = /^([+-])(\\d{2})(?::?(\\d{2}))?$/;\nfunction splitDateString(dateString) {\n  var dateStrings = {};\n  var array = dateString.split(patterns.dateTimeDelimiter);\n  var timeString;\n\n  // The regex match should only return at maximum two array elements.\n  // [date], [time], or [date, time].\n  if (array.length > 2) {\n    return dateStrings;\n  }\n  if (/:/.test(array[0])) {\n    timeString = array[0];\n  } else {\n    dateStrings.date = array[0];\n    timeString = array[1];\n    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {\n      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];\n      timeString = dateString.substr(dateStrings.date.length, dateString.length);\n    }\n  }\n  if (timeString) {\n    var token = patterns.timezone.exec(timeString);\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '');\n      dateStrings.timezone = token[1];\n    } else {\n      dateStrings.time = timeString;\n    }\n  }\n  return dateStrings;\n}\nfunction parseYear(dateString, additionalDigits) {\n  var regex = new RegExp('^(?:(\\\\d{4}|[+-]\\\\d{' + (4 + additionalDigits) + '})|(\\\\d{2}|[+-]\\\\d{' + (2 + additionalDigits) + '})$)');\n  var captures = dateString.match(regex);\n  // Invalid ISO-formatted year\n  if (!captures) return {\n    year: NaN,\n    restDateString: ''\n  };\n  var year = captures[1] ? parseInt(captures[1]) : null;\n  var century = captures[2] ? parseInt(captures[2]) : null;\n\n  // either year or century is null, not both\n  return {\n    year: century === null ? year : century * 100,\n    restDateString: dateString.slice((captures[1] || captures[2]).length)\n  };\n}\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) return new Date(NaN);\n  var captures = dateString.match(dateRegex);\n  // Invalid ISO-formatted string\n  if (!captures) return new Date(NaN);\n  var isWeekDate = !!captures[4];\n  var dayOfYear = parseDateUnit(captures[1]);\n  var month = parseDateUnit(captures[2]) - 1;\n  var day = parseDateUnit(captures[3]);\n  var week = parseDateUnit(captures[4]);\n  var dayOfWeek = parseDateUnit(captures[5]) - 1;\n  if (isWeekDate) {\n    if (!validateWeekDate(year, week, dayOfWeek)) {\n      return new Date(NaN);\n    }\n    return dayOfISOWeekYear(year, week, dayOfWeek);\n  } else {\n    var date = new Date(0);\n    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));\n    return date;\n  }\n}\nfunction parseDateUnit(value) {\n  return value ? parseInt(value) : 1;\n}\nfunction parseTime(timeString) {\n  var captures = timeString.match(timeRegex);\n  if (!captures) return NaN; // Invalid ISO-formatted time\n\n  var hours = parseTimeUnit(captures[1]);\n  var minutes = parseTimeUnit(captures[2]);\n  var seconds = parseTimeUnit(captures[3]);\n  if (!validateTime(hours, minutes, seconds)) {\n    return NaN;\n  }\n  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000;\n}\nfunction parseTimeUnit(value) {\n  return value && parseFloat(value.replace(',', '.')) || 0;\n}\nfunction parseTimezone(timezoneString) {\n  if (timezoneString === 'Z') return 0;\n  var captures = timezoneString.match(timezoneRegex);\n  if (!captures) return 0;\n  var sign = captures[1] === '+' ? -1 : 1;\n  var hours = parseInt(captures[2]);\n  var minutes = captures[3] && parseInt(captures[3]) || 0;\n  if (!validateTimezone(hours, minutes)) {\n    return NaN;\n  }\n  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);\n}\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n  var date = new Date(0);\n  date.setUTCFullYear(isoWeekYear, 0, 4);\n  var fourthOfJanuaryDay = date.getUTCDay() || 7;\n  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date;\n}\n\n// Validation functions\n\n// February is null to handle the leap year (using ||)\nvar daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction isLeapYearIndex(year) {\n  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;\n}\nfunction validateDate(year, month, date) {\n  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));\n}\nfunction validateDayOfYearDate(year, dayOfYear) {\n  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);\n}\nfunction validateWeekDate(_year, week, day) {\n  return week >= 1 && week <= 53 && day >= 0 && day <= 6;\n}\nfunction validateTime(hours, minutes, seconds) {\n  if (hours === 24) {\n    return minutes === 0 && seconds === 0;\n  }\n  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;\n}\nfunction validateTimezone(_hours, minutes) {\n  return minutes >= 0 && minutes <= 59;\n}"],"names":["requiredArgs","required","args","length","TypeError","_typeof","o","Symbol","iterator","constructor","prototype","toDate","argument","arguments","argStr","Object","toString","call","Date","getTime","console","warn","Error","stack","NaN","getTimezoneOffsetInMilliseconds","date","utcDate","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","setUTCFullYear","startOfDay","dirtyDate","setHours","MILLISECONDS_IN_DAY","differenceInCalendarDays","dirtyDateLeft","dirtyDateRight","startOfDayLeft","startOfDayRight","timestampLeft","timestampRight","Math","round","compareLocalAsc","dateLeft","dateRight","diff","differenceInDays","sign","difference","abs","setDate","isLastDayNotFull","Number","result","pow","millisecondsInMinute","millisecondsInHour","toInteger","dirtyNumber","number","isNaN","ceil","floor","parseISO","options","_options$additionalDi","additionalDigits","RangeError","dateStrings","splitDateString","parseYearResult","parseYear","parseDate","restDateString","year","offset","timestamp","time","parseTime","timezone","setFullYear","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","parseTimezone","patterns","dateTimeDelimiter","timeZoneDelimiter","dateRegex","timeRegex","timezoneRegex","dateString","timeString","array","split","test","substr","token","exec","replace","regex","RegExp","captures","match","parseInt","century","slice","isWeekDate","dayOfYear","parseDateUnit","month","day","week","dayOfWeek","validateWeekDate","dayOfISOWeekYear","validateDate","validateDayOfYearDate","max","value","hours","parseTimeUnit","minutes","seconds","validateTime","parseFloat","timezoneString","validateTimezone","isoWeekYear","fourthOfJanuaryDay","getUTCDay","setUTCDate","daysInMonths","isLeapYearIndex","_year","_hours"],"sourceRoot":""}